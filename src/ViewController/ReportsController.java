package ViewController;


import DAO.AppointmentDaoImpl;
import DAO.ContactDaoImpl;
import Model.Appointment;
import Model.Contact;
import Model.ReportTuple;
import javafx.beans.property.ReadOnlyObjectWrapper;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.event.ActionEvent;
import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.fxml.Initializable;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.scene.control.*;
import javafx.scene.control.cell.PropertyValueFactory;
import javafx.stage.Stage;

import java.io.IOException;
import java.net.URL;
import java.sql.SQLException;
import java.time.*;
import java.time.format.DateTimeFormatter;
import java.time.temporal.ChronoUnit;
import java.util.ResourceBundle;

/** This class controls the ReportsController screen.*/
public class ReportsController implements Initializable {

    Stage stage;
    Parent scene;

    /** This method switches the screen to the location specified by the location parameter.
     * @param location path to the screen to load
     * @param event ActionEvent caused by the user clicking a button*/
    public void switchScreen(String location, ActionEvent event) throws IOException {
        stage = (Stage)((Button)event.getSource()).getScene().getWindow();
        scene = FXMLLoader.load(getClass().getResource(location));
        stage.setScene(new Scene(scene));
        stage.show();
    }

    /**This method converts a number of minutes into hh:mm format.
     * @param minutes The minutes to convert
     * @return string with the minutes in hh:mm format*/
    public String convertToHoursAndMinutes(int minutes) {
        if(minutes%60 < 10)
            return minutes/60 + ":0" + minutes%60;
        else
            return minutes/60 + ":" + minutes%60;
    }

    @FXML
    private TableView<ReportTuple> appointmentsByTypeView;

    @FXML
    private TableColumn<ReportTuple, String> apptByTypeTypeCol;

    @FXML
    private TableColumn<ReportTuple, Integer> apptByTypeNumApptCol;

    @FXML
    private TableView<ReportTuple> appointmentsByMonthView;

    @FXML
    private TableColumn<ReportTuple, String> apptByMonthMonthCol;

    @FXML
    private TableColumn<ReportTuple, Integer> apptByMonthNumApptCol;

    @FXML
    private TableView<ReportTuple> appointmentHoursByWeekView;

    @FXML
    private TableColumn<ReportTuple, String> apptHoursByWeekWeekCol;

    @FXML
    private TableColumn<ReportTuple, Integer> apptHoursByWeekHoursCol;

    @FXML
    private ComboBox<Contact> contactCombo;

    @FXML
    private TableView<Appointment> contactScheduleView;

    @FXML
    private TableColumn<Appointment, Integer> contactScheduleApptIDCol;

    @FXML
    private TableColumn<Appointment, String> contactScheduleTitleCol;

    @FXML
    private TableColumn<Appointment, String> contactScheduleDescriptionCol;

    @FXML
    private TableColumn<Appointment, String> contactScheduleTypeCol;

    @FXML
    private TableColumn<Appointment, LocalDateTime> contactScheduleStartCol;

    @FXML
    private TableColumn<Appointment, LocalDateTime> contactScheduleEndCol;

    @FXML
    private TableColumn<Appointment, Integer> contactScheduleCustomerIDCol;

    /**This is the onActionUpdateContactScheduleView event handler. When a Contact is selected in contactCombo, the handler populates contactScheduleView with the appointments associated with the contact.
     * @param event ActionEvent generated by the user selecting a contact.*/
    @FXML
    public void onActionUpdateContactScheduleView(ActionEvent event) throws SQLException {
        if(contactCombo.getSelectionModel().getSelectedItem() == null)
            return;

        ObservableList<Appointment> allAppointments = AppointmentDaoImpl.getAllAppointments();
        ObservableList<Appointment> filteredAppointments = FXCollections.observableArrayList();

        for(Appointment appointment : allAppointments) {
            if(contactCombo.getSelectionModel().getSelectedItem().getContactId() == appointment.getContact().getContactId())
                filteredAppointments.add(appointment);
        }

        if(filteredAppointments.isEmpty()) {
            contactScheduleView.setPlaceholder(new Label("The selected contact has no scheduled appointments."));
        }
        contactScheduleView.setItems(filteredAppointments);
    }

    /** This is the onActionDisplayMenu event handler.
     * When the Menu button is clicked, the handler switches to the Menu screen.
     * @param event ActionEvent generated by the user clicking the Menu button.*/
    @FXML
    public void onActionDisplayMenu(ActionEvent event) throws IOException {
        switchScreen("/ViewController/Menu.fxml", event);
    }

    /**This is the onActionExitApplication event handler. When the Exit button is clicked, this handler exits the java application.
     * @param event ActionEvent is generated when the user clicks the exit button in the Reports screen*/
    @FXML
    public void onActionExitApplication(ActionEvent event) {
        System.exit(0);
    }

    /**This is the initialize method (Lambda Discussion #2).
     *
     * Lambda Discussion 2:
     *
     * The initialize method in ReportsController instantiates the ReportsInterface three times with lambda expressions.
     * The initialize method needs to generate three reports to populate TableViews automatically when the Reports screen is loaded.
     * This is accomplished with the abstract method of the ReportsInterface called generateReport.
     * The generateReport method has no parameters and it returns an observable list of ReportTuple objects.
     * The ReportTuple object is meant to represent a single record in the report, which is a single row in the TableView of a report in the user interface.
     * Each ReportTuple has two fields, an appointment attribute and an appointment attribute quantity.
     * The appointment attribute is the string data that appears in the first column of the report.
     * For example, one appointment attribute is the month an appointment is scheduled for, such as 'JANUARY'.
     * The appointment attribute quantity is the quantity associated with the attribute, appearing in the second column of the report.
     * For example, one appointment attribute quantity is the amount of appointments scheduled for a given month.
     * Since each report to be generated can be represented in the format of a list of ReportTuples, they can be generated by instantiating the same functional interface.
     * Lambda expressions were useful in this case because they allowed the same abstract method to be called three times to create three unique reports.
     * If more reports needed to be added to the application, it would be simple to add more lambda expressions to instantiate the ReportsInterface.
     * @param rb resource bundle
     * @param url URL*/
    @Override
    public void initialize(URL url, ResourceBundle rb) {

        ReportsInterface apptsByType = () -> {
            ObservableList<Appointment> allAppointments = AppointmentDaoImpl.getAllAppointments();
            ObservableList<ReportTuple> apptsByTypeViewTuples = FXCollections.observableArrayList();

            for(Appointment appointment : allAppointments) {
                String type = appointment.getType();
                boolean typeFound = false;
                for(ReportTuple reportTuple : apptsByTypeViewTuples) {
                    if(type.equals(reportTuple.getAppointmentAttribute())) {
                        reportTuple.setAppointmentAttributeQuantity(reportTuple.getAppointmentAttributeQuantity() + 1);
                        typeFound = true;
                        break;
                    }
                }
                if(!typeFound) {
                    ReportTuple reportTuple = new ReportTuple(type, 1);
                    apptsByTypeViewTuples.add(reportTuple);
                }
            }

            return apptsByTypeViewTuples;
        };

        ReportsInterface apptsByMonth = () -> {
            ObservableList<Appointment> allAppointments = AppointmentDaoImpl.getAllAppointments();
            ObservableList<ReportTuple> apptsByTypeViewTuples = FXCollections.observableArrayList();

            for(int i = 1; i <= 12; ++i) {
                apptsByTypeViewTuples.add(new ReportTuple(Month.of(i).toString(), 0));
            }

            for(Appointment appointment : allAppointments) {
                String month = String.valueOf(appointment.getStart().getMonth());
                boolean typeFound = false;
                if(appointment.getStart().toLocalDate().isBefore(LocalDate.now()) || appointment.getStart().isAfter(LocalDateTime.of(Year.now().getValue() + 1, appointment.getStart().getMonth(), 1, 0, 0, 0)))
                    continue;
                for(ReportTuple reportTuple : apptsByTypeViewTuples) {
                    if(month.equals(reportTuple.getAppointmentAttribute())) {
                        reportTuple.setAppointmentAttributeQuantity(reportTuple.getAppointmentAttributeQuantity() + 1);
                        typeFound = true;
                        break;
                    }
                }
            }

            return apptsByTypeViewTuples;
        };

        ReportsInterface apptHoursByWeek = () -> {
            ObservableList<Appointment> allAppointments = AppointmentDaoImpl.getAllAppointments();
            ObservableList<ReportTuple> apptsByTypeViewTuples = FXCollections.observableArrayList();

            LocalDate today = LocalDate.now();
            DayOfWeek dayOfWeek = today.getDayOfWeek();

            for(int i = 0; i < 9; ++i) {
                LocalDate startOfWeek = today.plusDays(7 * i - dayOfWeek.getValue() + 1);
                LocalDate endOfWeek = today.plusDays(7 * i - dayOfWeek.getValue() + 7);
                String startMonth = startOfWeek.getMonth().toString().substring(0, 1) + startOfWeek.getMonth().toString().substring(1).toLowerCase();
                String endMonth = endOfWeek.getMonth().toString().substring(0, 1) + endOfWeek.getMonth().toString().substring(1).toLowerCase();
                String week = "From " + startMonth + " " + startOfWeek.getDayOfMonth() + " To " + endMonth + " " + endOfWeek.getDayOfMonth();

                int minutes = 0;

                for(Appointment appointment : allAppointments) {
                    if(!appointment.getStart().toLocalDate().isBefore(startOfWeek) &&
                            !appointment.getStart().toLocalDate().isAfter(endOfWeek)) {
                        LocalDateTime start = appointment.getStart();
                        LocalDateTime end = appointment.getEnd();
                        int appointmentLength = (int) ChronoUnit.MINUTES.between(start, end);
                        minutes = minutes + appointmentLength;
                    }
                }


                apptsByTypeViewTuples.add(new ReportTuple(week, minutes));
            }

            return apptsByTypeViewTuples;
        };

        try {
            contactCombo.setItems(ContactDaoImpl.getAllContacts());
        } catch (SQLException e) {
            e.printStackTrace();
        }

        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm");

        contactScheduleApptIDCol.setCellValueFactory(new PropertyValueFactory<>("appointmentId"));
        contactScheduleTitleCol.setCellValueFactory(new PropertyValueFactory<>("title"));
        contactScheduleDescriptionCol.setCellValueFactory(new PropertyValueFactory<>("description"));
        contactScheduleTypeCol.setCellValueFactory(new PropertyValueFactory<>("type"));
        this.contactScheduleStartCol.setCellValueFactory((cellData) -> {
            return new ReadOnlyObjectWrapper((cellData.getValue()).getStart().format(formatter));
        });
        this.contactScheduleEndCol.setCellValueFactory((cellData) -> {
            return new ReadOnlyObjectWrapper((cellData.getValue()).getEnd().format(formatter));
        });
        contactScheduleCustomerIDCol.setCellValueFactory(new PropertyValueFactory<>("customerId"));

        apptByTypeTypeCol.setCellValueFactory(new PropertyValueFactory<>("appointmentAttribute"));
        apptByTypeNumApptCol.setCellValueFactory(new PropertyValueFactory<>("appointmentAttributeQuantity"));
        try {
            appointmentsByTypeView.setItems(apptsByType.generateReport());
        } catch (SQLException e) {
            e.printStackTrace();
        }

        this.apptByMonthMonthCol.setCellValueFactory((cellData) -> {
            return new ReadOnlyObjectWrapper(Month.valueOf((cellData.getValue()).getAppointmentAttribute()));
        });
        apptByMonthNumApptCol.setCellValueFactory(new PropertyValueFactory<>("appointmentAttributeQuantity"));
        try {
            appointmentsByMonthView.setItems(apptsByMonth.generateReport());
        } catch (SQLException e) {
            e.printStackTrace();
        }


        apptHoursByWeekWeekCol.setCellValueFactory(new PropertyValueFactory<>("appointmentAttribute"));
        apptHoursByWeekHoursCol.setCellValueFactory(new PropertyValueFactory<>("appointmentAttributeQuantity"));
        this.apptHoursByWeekHoursCol.setCellValueFactory((cellData) -> {
            return new ReadOnlyObjectWrapper(convertToHoursAndMinutes((cellData.getValue()).getAppointmentAttributeQuantity()));
        });
        try {
            appointmentHoursByWeekView.setItems(apptHoursByWeek.generateReport());
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
}
